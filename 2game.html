<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>2048 ‚Äî Demo</title>
<style>
  :root{
    --bg:#faf8ef;
    --board:#bbada0;
    --cell:#cdc1b4;
    --tile-font: 'Segoe UI', Roboto, Arial, sans-serif;
  }
  html,body{height:100%}
  body{
    margin:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background:linear-gradient(180deg,#f5f0e6,#fdfcfb);
    font-family:var(--tile-font);
    color:#776e65;
  }
  .game {
    width:360px;
    max-width:calc(100vw - 32px);
  }
  .header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-bottom:12px;
  }
  h1{
    margin:0;
    font-size:28px;
    letter-spacing:1px;
  }
  .score {
    background:#eee4da;
    padding:10px 14px;
    border-radius:6px;
    text-align:center;
    min-width:90px;
  }
  .controls {
    display:flex;
    gap:8px;
    margin-bottom:10px;
  }
  .btn{
    background:#8f7a66;
    color:white;
    padding:8px 12px;
    border-radius:6px;
    text-decoration:none;
    cursor:pointer;
    user-select:none;
    font-size:14px;
  }
  .board {
    background:var(--board);
    padding:16px;
    border-radius:6px;
    position:relative;
  }
  .grid {
    display:grid;
    grid-template-columns: repeat(4,1fr);
    gap:12px;
  }
  .cell {
    background:var(--cell);
    width:72px;
    height:72px;
    display:flex;
    align-items:center;
    justify-content:center;
    border-radius:6px;
    font-size:0; /* text inside tile not cell */
  }
  .tile {
    position:relative;
    width:72px;
    height:72px;
    display:flex;
    align-items:center;
    justify-content:center;
    border-radius:6px;
    font-weight:700;
    font-size:24px;
    transition: transform 120ms ease, background 120ms linear, box-shadow 120ms;
    will-change: transform;
    box-shadow: 0 3px 0 rgba(0,0,0,0.05);
  }

  /* tile colors (common set) */
  .tile-2{ background:#eee4da; color:#776e65; }
  .tile-4{ background:#ede0c8; color:#776e65; }
  .tile-8{ background:#f2b179; color:#f9f6f2; }
  .tile-16{ background:#f59563; color:#f9f6f2; }
  .tile-32{ background:#f67c5f; color:#f9f6f2; }
  .tile-64{ background:#f65e3b; color:#f9f6f2; }
  .tile-128{ background:#edcf72; color:#f9f6f2; font-size:20px; }
  .tile-256{ background:#edcc61; color:#f9f6f2; font-size:20px; }
  .tile-512{ background:#edc850; color:#f9f6f2; font-size:20px; }
  .tile-1024{ background:#edc53f; color:#f9f6f2; font-size:18px; }
  .tile-2048{ background:#edc22e; color:#f9f6f2; font-size:18px; }

  .overlay{
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background:rgba(250,248,239,0.9);
    border-radius:6px;
    flex-direction:column;
    gap:12px;
    font-size:20px;
  }
  .muted { color:#8f8a85; font-size:13px; text-align:center; max-width:240px;}
  .small { font-size:13px; color:#776e65; }

  /* responsive */
  @media (max-width:420px){
    .cell, .tile { width:60px; height:60px; }
    .grid { gap:10px; }
    .tile { font-size:20px; }
  }
</style>
</head>
<body>
  <div class="game" id="game">
    <div class="header">
      <h1>2048</h1>
      <div class="score" id="scoreBox">
        <div style="font-size:12px;opacity:0.8">Score</div>
        <div id="score" style="font-size:18px; font-weight:800">0</div>
      </div>
    </div>

    <div class="controls">
      <div class="btn" id="newGameBtn">New Game</div>
      <div class="btn" id="undoBtn">Undo</div>
    </div>

    <div class="board" id="boardRoot" aria-live="polite">
      <div class="grid" id="grid">
        <!-- 16 cell placeholders created by JS -->
      </div>
      <!-- overlays injected by JS -->
    </div>

    <div class="small" style="margin-top:10px">
      Use arrow keys( ‚Üê ‚Üë ‚Üí ‚Üì). Merge tiles to reach 2048.
    </div>
  </div>

<script>
/*
  Simple 2048 implementation in vanilla JS.
  - Board is 4x4.
  - Maintains score and basic undo (single step).
  - Supports keyboard and swipe gestures.
  - Logic: compress -> merge -> compress for moves.
*/

const SIZE = 4;
let board = [];
let score = 0;
let bestScore = 0;
let canMove = true;
let previous = null; // for undo (store {board,score})

const root = document.getElementById('game');
const gridEl = document.getElementById('grid');
const scoreEl = document.getElementById('score');
const boardRoot = document.getElementById('boardRoot');

function makeEmptyBoard() {
  const b = [];
  for (let r=0;r<SIZE;r++){
    b.push(new Array(SIZE).fill(0));
  }
  return b;
}

function copyBoard(b){
  return b.map(row => row.slice());
}

function placeCellPlaceholders(){
  gridEl.innerHTML = '';
  for (let i=0;i<SIZE*SIZE;i++){
    const cell = document.createElement('div');
    cell.className = 'cell';
    gridEl.appendChild(cell);
  }
}

function init() {
  placeCellPlaceholders();
  board = makeEmptyBoard();
  score = 0;
  previous = null;
  updateScore();
  addRandomTile();
  addRandomTile();
  render();
  removeOverlay();
  canMove = true;
}

function updateScore(){
  scoreEl.textContent = score;
}

function addRandomTile(){
  const empties = [];
  for (let r=0;r<SIZE;r++){
    for (let c=0;c<SIZE;c++){
      if (board[r][c] === 0) empties.push([r,c]);
    }
  }
  if (empties.length === 0) return false;
  const idx = Math.floor(Math.random()*empties.length);
  const [r,c] = empties[idx];
  // 90% chance 2, 10% chance 4
  board[r][c] = Math.random() < 0.9 ? 2 : 4;
  return true;
}

function render(){
  // remove old tiles
  // We'll create tile elements and position them using grid order
  // Clear existing tiles placed inside cells
  // Simpler approach: each cell contains either empty or a .tile
  const cells = gridEl.children;
  for (let i=0;i<cells.length;i++){
    cells[i].innerHTML = ''; // clear
  }

  for (let r=0;r<SIZE;r++){
    for (let c=0;c<SIZE;c++){
      const val = board[r][c];
      if (val !== 0){
        const tile = document.createElement('div');
        tile.className = 'tile tile-' + val;
        tile.textContent = val;
        // font size adjust for large numbers
        if (val >= 1024) tile.style.fontSize = '16px';
        // place into cell index
        const index = r*SIZE + c;
        cells[index].appendChild(tile);
      }
    }
  }
}

function compressRow(row){
  // slide non-zero numbers to left preserving order
  const newRow = row.filter(v => v !== 0);
  while (newRow.length < SIZE) newRow.push(0);
  return newRow;
}

function mergeRow(row){
  // merge equal adjacent starting from left
  for (let i=0;i<SIZE-1;i++){
    if (row[i] !== 0 && row[i] === row[i+1]){
      row[i] *= 2;
      row[i+1] = 0;
      score += row[i];
    }
  }
  return row;
}

function moveLeft(b){
  let changed = false;
  const newB = makeEmptyBoard();
  for (let r=0;r<SIZE;r++){
    let row = b[r].slice();
    row = compressRow(row);
    row = mergeRow(row);
    row = compressRow(row);
    newB[r] = row;
    if (!changed && row.some((v,i)=> v !== b[r][i])) changed = true;
  }
  return {board:newB, changed};
}

function rotateClockwise(b){
  const nb = makeEmptyBoard();
  for (let r=0;r<SIZE;r++){
    for (let c=0;c<SIZE;c++){
      nb[c][SIZE-1-r] = b[r][c];
    }
  }
  return nb;
}
function rotateCounter(b){
  // 3 clockwise rotations
  return rotateClockwise(rotateClockwise(rotateClockwise(b)));
}

function move(direction){ // 'left','right','up','down'
  if(!canMove) return;
  // save previous for undo
  previous = { board: copyBoard(board), score: score };

  let rotated;
  let result;
  if (direction === 'left'){
    result = moveLeft(board);
  } else if (direction === 'right'){
    // mirror horizontally: rotate twice and move left? simpler: rotate 180 -> left -> rotate 180
    rotated = rotateClockwise(rotateClockwise(board));
    result = moveLeft(rotated);
    result.board = rotateClockwise(rotateClockwise(result.board));
  } else if (direction === 'up'){
    rotated = rotateCounter(board); // rotate left (ccw)
    result = moveLeft(rotated);
    result.board = rotateClockwise(result.board); // rotate back
  } else if (direction === 'down'){
    rotated = rotateClockwise(board);
    result = moveLeft(rotated);
    result.board = rotateCounter(result.board);
  } else return;

  if (result.changed){
    board = result.board;
    addRandomTile();
    updateScore();
    render();
    if (checkWin()){
      showOverlay(true, 'You win! üéâ', 'Press "New Game" to play again, or keep going.');
    } else if (!hasMoves()){
      showOverlay(false, 'Game over', 'No moves left ‚Äî try again!');
    }
  } else {
    // no change ‚Äî don't overwrite previous snapshot
    previous = null;
  }
}

function hasMoves(){
  // check for any zero or any adjacent equal pair
  for (let r=0;r<SIZE;r++){
    for (let c=0;c<SIZE;c++){
      if (board[r][c] === 0) return true;
      if (c < SIZE-1 && board[r][c] === board[r][c+1]) return true;
      if (r < SIZE-1 && board[r][c] === board[r+1][c]) return true;
    }
  }
  return false;
}

function checkWin(){
  for (let r=0;r<SIZE;r++){
    for (let c=0;c<SIZE;c++){
      if (board[r][c] >= 2048) return true;
    }
  }
  return false;
}

/* UI overlays */
function showOverlay(isWin, title, subtitle){
  removeOverlay();
  const ov = document.createElement('div');
  ov.className = 'overlay';
  const t = document.createElement('div');
  t.style.fontWeight = 800;
  t.style.fontSize = '22px';
  t.textContent = title || (isWin ? 'You win!' : 'Game over');
  const sub = document.createElement('div');
  sub.className = 'muted';
  sub.textContent = subtitle || '';
  const rbtn = document.createElement('div');
  rbtn.className = 'btn';
  rbtn.textContent = 'New Game';
  rbtn.onclick = () => { init(); };
  ov.appendChild(t);
  ov.appendChild(sub);
  ov.appendChild(rbtn);
  boardRoot.appendChild(ov);
  canMove = false;
}

function removeOverlay(){
  const ov = boardRoot.querySelector('.overlay');
  if (ov) ov.remove();
  canMove = true;
}

/* Undo */
document.getElementById('undoBtn').addEventListener('click', ()=>{
  if(!previous) return;
  board = copyBoard(previous.board);
  score = previous.score;
  previous = null;
  updateScore();
  render();
  removeOverlay();
});

/* New game */
document.getElementById('newGameBtn').addEventListener('click', init);

/* Keyboard handlers */
window.addEventListener('keydown', (e)=>{
  if (!canMove) return;
  let handled = true;
  switch (e.key){
    case 'ArrowLeft': move('left'); break;
    case 'ArrowRight': move('right'); break;
    case 'ArrowUp': move('up'); break;
    case 'ArrowDown': move('down'); break;
    case 'r': init(); break;
    default: handled = false;
  }
  if (handled) e.preventDefault();
});

/* Touch (swipe) handlers */
let touchStartX = 0, touchStartY = 0;
const threshold = 30;
boardRoot.addEventListener('touchstart', (ev)=>{
  if (ev.touches.length === 1){
    touchStartX = ev.touches[0].clientX;
    touchStartY = ev.touches[0].clientY;
  }
});
boardRoot.addEventListener('touchend', (ev)=>{
  if (!canMove) return;
  const t = ev.changedTouches[0];
  const dx = t.clientX - touchStartX;
  const dy = t.clientY - touchStartY;
  if (Math.abs(dx) < threshold && Math.abs(dy) < threshold) return;
  if (Math.abs(dx) > Math.abs(dy)){
    if (dx > 0) move('right'); else move('left');
  } else {
    if (dy > 0) move('down'); else move('up');
  }
});

/* Simple helpers for debugging in console */
window._getBoard = () => board;

/* Detect if move was possible after each move (we already do), but keep UI updated */
function gameLoopTick(){}
setInterval(gameLoopTick, 200);

/* Initialize on load */
init();

</script>
</body>
</html>
